---
layout: post
title: Java Thread
categories: Java
description: Java 线程
keywords: Java
---


线程分类
- 用户线程
- 守护线程

创建线程方式
1. 继承Thread,重写run()
2. 实现Runnable,实现run()
3. 实现Callable接口

线程的启动
- 新建的线程不会自动开始运行，必须通过start( )方法启动 
- 不能直接调用run()来启动线程，这样run()将作为一个普通方法立即执行，执行完毕前其他线 程无法兵法执行 
- Java程序启动时，会立刻创建主线程，main就是在这个线程上运行。当不再产生新线程时， 程序是单线程的

1.2两种线程创建方式的比较
- 继承Thread类方式的多线程 
    - 优势：编写简单 
    - 劣势：无法继承其它父类
- 实现Runnable接口方式的多线程 
    - 优势：可以继承其它类，多线程可共享同一个Runnable对象 
    - 劣势：编程方式稍微复杂，如果需要访问当前线程，需要调用Thread.currentThread()方 法
- 实现Runnable接口方式要通用一些。

第3种Callable接口方式
- 与实行Runnable相比， Callable功能更强大些 
- 方法不同  
- 可以有返回值，支持泛型的返回值 
- 可以抛出异常 
- 需要借助FutureTask，比如获取返回结果
- Future接口 
    - 可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。 
    - FutrueTask是Futrue接口的唯一的实现类 
    - FutureTask 同时实现了Runnable,Future接口。它既可以作为Runnable被线程执行，又可以作为 Future得到Callable的返回值

匿名内部类lamda推导必须存在类型


线程的生命周期
- 新生状态： 
    - 用new关键字建立一个线程对象后，该线程对象就处于新生状态。 
    - 处于新生状态的线程有自己的内存空间，通过调用start进入就绪状态 
- 就绪状态： 
    - 处于就绪状态线程具备了运行条件，但还没分配到CPU，处于线程就绪队列，等待系统为其分配CPU 
    - 当系统选定一个等待执行的线程后，它就会从就绪状态进入执行状态，该动作称之为“cpu调度”。 
- 运行状态： 
    - 在运行状态的线程执行自己的run方法中代码，直到等待某资源而阻塞或完成任务而死亡。 
    - 如果在给定的时间片内没有执行结束，就会被系统给换下来回到等待执行状态。 
- 阻塞状态：(同步阻塞 等待阻塞 其他阻塞)
    - 处于运行状态的线程在某些情况下，如执行了sleep（睡眠）方法，或等待I/O设备等资源，将让出CPU并暂时停止自己的运行，进 入阻塞状态。 
    - 在阻塞状态的线程不能进入就绪队列。只有当引起阻塞的原因消除时，如睡眠时间已到，或等待的I/O设备空闲下来，线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续运行。 
- 死亡状态： 
    - 死亡状态是线程生命周期中的最后一个阶段。线程死亡的原因有三个。一个是正常运行的线程完成了它的全部工作；另一个是线程被强制性地终止，如通过执行stop方法来终止一个线程[不推荐使用]，三是线程抛出未捕获的异常

线程状态转移
- 进入就绪
    - start
    - 解除
    - yeild
    - JVM调度
- 进入阻塞
    - sleep(其他阻塞)
    - wait(等待阻塞)
    - join(其他阻塞)
    - IO阻塞(其他阻塞)
- 进入死亡
    - stop destroy(过时)

Jave Thread.State
- NEW
- RUNNABLE
- BLOCKED
- WAITING
- TIMED_WAITING
- TERMINATED

生命周期
![lifecycle](/images/java/lifecycle.png)


线程控制方法
- join () (插队)
    - 阻塞指定线程等到另一个线程完成以后再继续执行 
- sleep () 
    - 使线程停止运行一段时间，将处于阻塞状态 
    - 如果调用了sleep方法之后，没有其他等待执行的线程，这个时候当前线程不会马上恢复执行！ 
- yield () 
    - 让当前正在执行线程暂停，不是阻塞线程，而是将线程转入就绪状态 
    - 如果调用了yield方法之后，没有其他等待执行的线程，这个时候当前线程就会马上恢复执行！ 
- setDaemon() 
    - 可以将指定的线程设置成后台线程 
    - 创建后台线程的线程结束时，后台线程也随之消亡 
    - 只能在线程启动之前把它设为后台线程 
- interrupt() 
    - 并没有直接中断线程，而是需要被中断线程自己处理 
- stop() 
    - 结束线程，不推荐使用

并发：同一个对象对多个线程同时操作  
线程同步实现方式
- 同步代码块 synchronized (obj){    } 
- 同步方法  private synchronized void makeWithdrawal(int amt) {}

- 局部块
- 构造块
- 静态块
- 同步块


同步监视器
- synchronized (obj){    }中的obj称为同步监视器 
- 同步代码块中同步监视器可以是任何对象，但是推荐使用共享资源作为同步监视器 
- 同步方法中无需指定同步监视器，因为同步方法的同步监视器是this，也就是该对象本事

同步监视器执行过程
- 第一个线程访问，锁定同步监视器，执行其中代码 
- 第二个线程访问，发现同步监视器被锁定，无法访问 
- 第一个线程访问完毕，解锁同步监视器 
- 第二个线程访问，发现同步监视器未锁，锁定并访问

操作并发容器 CopyOnWriteArrayList


线程通信
- 协作模型:生产者消费者实现方式一:管程法
- 协作模型:生产者消费者实现方式二:信号灯法

- wait()   :线程阻塞，释放锁
- notify() :锁池状态，

volatile保证线程间变量的可见性，但不能保证原子性 
* DCL单例模式: 懒汉式套路基础上加入并发控制，保证在多线程环境下，对外存在一个对象
* 1、构造器私有化 -->避免外部new构造器
* 2、提供私有的静态volatile属性 -->存储对象的地址
    - 没有volatile其他线程可能访问一个没有初始化的对象(指令重排的原因)
* 3、提供公共的静态方法 --> 获取属性

ThreadLocal
- 每个线程自身的存储本地、局部区域
- 分析上下文 环境  起点
    * 构造器: 哪里调用 就属于哪里 找线程体
    * run方法:本线程自身的

可重入锁 ReentrantLock 锁可以延续使用
不可重入锁  锁不可以延续使用

Lock锁
- Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁 
- Lock只有代码块锁，synchronized有代码块锁和方法锁 
- 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类） 

优先使用顺序： 
- Lock--同步代码块（已经进入了方法体，分配了相应资源）--同步方法（在方法体之外）

CAS(Compare and Swap) Atomic 原子操作 硬件级别操作
- 悲观锁：synchronized 独占锁
- 乐观锁


