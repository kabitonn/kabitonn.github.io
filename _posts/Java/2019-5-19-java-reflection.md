---
layout: post
title: Java Annotation Reflection
categories: Java
description: Java 注解 反射 动态性
keywords: Java
---



注解
Annotation的作用： 
- 不是程序本身，可以对程序作出解释。(这一点，跟注释没什么区别) 
- 可以被其他程序(比如：编译器等)读取。(注解信息处理流程，是注解和注释的重大区别。如果没有注解信息处理流程，则注解毫无意义) 

Annotation的格式： 
- 注解是以“@注释名”在代码中存在的，还可以添加一些参数值，例如： @SuppressWarnings(value="unchecked")。 

Annotation在哪里使用?
- 可以附加在package, class, method, field等上面，相当于给它们添加了额外的辅助信 息，我们可以通过反射机制编程实现对这些元数据的访问。

@Override 
- 定义在java.lang.Override中，此注释只适用于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明。 
@Deprecated 
- 定义在java.lang.Deprecated中，此注释可用于修辞方法、属性、类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或存在更 好的选择。
@SuppressWarnings 
- 定义在java.lang.SuppressWarnings中，用来抑制编译时的警告信息 。 
- 与前两个注释有所不同，你需要添加一个参数才能正确使用，这些参数值都是已经定义好了的，

自定义注解
- 使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口 
- 格式为： 
    - public @interface 注解名 {定义体} 
    - 其中的每一个方法实际上是声明了一个配置参数。 
    - 方法的名称就是参数的名称 
    - 返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum） 
    - 可以通过default来声明参数的默认值。 
    - 如果只有一个参数成员，一般参数名为value

注解
- 注解可以有属性,因为注解其实就是一个接口(类)     每次使用注解都需要导包
- 注解语法:@XXXX(属性名= 值)
- 值的分类
    - 如果值是基本数据类型或字符串: 属性名=值
    - 如果值是数组类型: 属性名={值,值}
        - 如果只有一个值可以省略大括号
    - 如果值是类类型,属性名=@名称
- 如果注解只需要给一个属性赋值,且这个属性是默认属性,可以省略属性名


元注解
元注解的作用就是负责注解其他注解。 Java定义了4个标准的 meta-annotation类型，它们被用来提供对其它 annotation 类型作说明。 
- @Target 用于描述注解的使用范围（即:被描述的注解可以用在什么地方）
- @Retention 表示需要在什么级别保存该注释信息，用于描述注解的生命周期
- @Documented 
- @Inherited 


Java的动态性
- 反射机制
- 动态编译
- 动态执行JavaScript代码
- 动态字节码操作

动态语言
- 程序运行时，可以改变程序结构或变量类型。典型的语言： Python、ruby、javascript等
- C,  C++,  JAVA不是动态语言，JAVA可以称之为“准动态语 言”。但是JAVA有一定的动态性，我们可以利用反射机制、 字节码操作获得类似动态语言的特性。

反射机制
- 指的是可以于运行时加载、探知、使用编译期间完全未知的类。 
- 程序在运行状态中，可以动态加载一个只有名称的类，对于任意一个已加载的类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；
 Class c = Class.forName(""); 
- 加载完类之后，在堆内存中，就产生了一个 Class 类型的对象（一个类只有一个 Class对象），这个对象就包含了完整的类的结构信息。 我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过 这个镜子看到类的结构，所以，我们形象的称之为：反射。 


Class类
- Class类的对象包含了某个被加载类的结构。一个被加载的类对应一个Class对象。 
- 当一个class被加载，或当加载器（class loader）的defineClass()被 JVM调用，JVM 便自动产生一个Class 对象。 
- Class类是Reflection的根源。 针对任何您想动态加载、运行的类，唯有先获得相应的Class 对象

反射机制的常见作用
- 动态加载类、动态获取类的信息（属性、方法、构造器）
- 动态构造对象 (javabean无参构造方法)
- 动态调用类和对象的任意方法、构造器 (invoke)
- 动态调用和处理属性 (set)
- 获取泛型信息
- 处理注解

反射操作泛型(Generic)
- Java采用泛型擦除的机制来引入泛型。Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换的麻烦。但是，一旦编译完成，所有的和泛型有关的类型全部擦除。
- 为了通过反射操作这些类型以迎合实际开发的需要，Java就新增了ParameterizedType，GenericArrayType，TypeVariable 和WildcardType几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型。
    - ParameterizedType: 表示一种参数化的类型，比如Collection<String> 
    - GenericArrayType: 表示一种元素类型是参数化类型或者类型变量的数组类型 
    - TypeVariable: 是各种类型变量的公共父接口 
    - WildcardType: 代表一种通配符类型表达式，比如?, ? extends Number, ? super Integer【wildcard是一个单词：就是“通配符”】

反射操作注解(annotation)
可以通过反射API:getAnnotations, getAnnotation获得相关的注解信息


反射机制性能
 setAccessible 
 - 启用和禁用访问安全检查的开关,值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查。值为 false 则指示反射的对象应该实施 Java 语言访问检查。并不是为true 就能访问为false就不能访问。 
 - 禁止安全检查，可以提高反射的运行速度。

动态编译
动态编译应用场景
- 可以做一个浏览器端编写java代码，上传服务器编译和运行的在线评测系统。 
- 服务器动态加载某些类文件进行编译 
动态编译两种做法
- 通过Runtime调用javac，启动新的进程去操作 Runtime run = Runtime.getRuntime();  Process process = run.exec("javac -cp d:/myjava/   HelloWorld.java"); 
- 通过JavaCompiler动态编译


脚本引擎执行javascript代码
- 使得 Java 应用程序可以通过一套固定的接口与各种脚本引擎交互，从 而达到在 Java 平台上调用各种脚本语言的目的。 
- Java 脚本 API 是连通 Java 平台和脚本语言的桥梁。 
- 可以把一些复杂异变的业务逻辑交给脚本语言处理，这又大大提高了 开发效率。

Java 脚本 API 为开发者提供了如下功能： 
- 获取脚本程序输入，通过脚本引擎运行脚本并返回运行结果，这是最 核心的接口。 
    - 注意是：接口。Java可以使用各种不同的实现，从而通用的调用js、 groovy、python等脚本。 
        - Js使用了：Rhino Rhino 是一种使用 Java 语言编写的 JavaScript 的开源实现，原先由Mozilla开发 ，现在被集成进入JDK 6.0。
- 通过脚本引擎的运行上下文在脚本和 Java 平台间交换数据。 
- 通过 Java 应用程序调用脚本函数。

类加载过程
类加载机制 - JVM把class文件加载到内存，并对数据进行校验、解析和初始化，最终形成 JVM可以直接使用的Java类型的过程。
- 加载 
    - 将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代 表这个类的java.lang.Class对象，作为方法区类数据的访问入口。 
- 链接  将Java类的二进制代码合并到JVM的运行状态之中的过程 
    - 验证： 确保加载的类信息符合JVM规范，没有安全方面的问题。 
    - 准备： 正式为类变量(static变量)分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配 
    - 解析： 虚拟机常量池内的符号引用替换为直接引用的过程 
- 初始化 
    - 初始化阶段是执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译器自动收集 类中的所有类变量的赋值动作和静态语句块(static块)中的语句合并产生的。 
    - 当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先出发其父类的初始化 
    - 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。
    - 类的主动引用（一定会发生类的初始化） 
        - new一个类的对象 - 调用类的静态成员(除了final常量)和静态方法 
        - 使用java.lang.reflect包的方法对类进行反射调用 
        - 当虚拟机启动，java  Hello，则一定会初始化Hello类。说白了就是先启动main方法所在的类 
        - 当初始化一个类，如果其父类没有被初始化，则先会初始化他的父类
    - 类的被动引用(不会发生类的初始化) 
        - 当访问一个静态域时，只有真正声明这个域的类才会被初始化 
        - 通过子类引用父类的静态变量，不会导致子类初始化 
        - 通过数组定义类引用，不会触发此类的初始化 
        - 引用常量不会触发此类的初始化（常量在编译阶段就存入调用类的常量池中了）

类加载器  
类加载器作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class 对象，作为方法区类数据的访问入口。  

类缓存：标准的Java SE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过，JVM垃圾收集器可以回收 这些Class对象。

java.class.ClassLoader类 
作用
- java.lang.ClassLoader类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 Java 类，即 java.lang.Class类的一个实例。 
- 除此之外，ClassLoader还负责加载 Java 应用所需的资源，如图像文 件和配置文件等。 

类加载器层次结构

引导类加载器（bootstrap class loader） 
- 它用来加载 Java 的核心库，是用原生代码C来实现的，并不继承自 java.lang.ClassLoader。 
- 加载扩展类和应用程序类加载器。并指定他们的父类加载器。 

扩展类加载器（extensions class loader） 
- 用来加载 Java 的扩展库。 Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。 
- 由$ExtClassLoader实现 

应用程序类加载器（application class loader） 
- 它根据 Java 应用的类路径（classpath， java.class.path 路径下的内容）来加载 Java 类。 一般来说，Java 应用的类都是由它来完成加载的。 - 由$AppClassLoader实现 

自定义类加载器 
- 开发人员可以通过继承 java.lang.ClassLoader类的方式 实现自己的类加载器，以满足一些特殊的需求。

类加载器的代理模式
代理模式 
- 交给其他加载器来加载指定的类
双亲委托机制 
- 就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次追溯，直到最高的爷爷辈的，如果父类加载器 可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。 
- 双亲委托机制是为了保证 Java 核心库的类型安全。
    - 这种机制就保证不会出现用户自己能定义java.lang.Object类的情况。 
- 类加载器除了用于加载类，也是安全的最基本的屏障。

 自定义类加载器的流程： 
 1. 首先检查请求的类型是否已经被这个类装载器装载到命名空间中了，如果已经装载，直接返回；否则转入步骤2 
 2. 委派类加载请求给父类加载器（更准确的说应该是双亲类加载器，真个虚拟机中各种类加载器最终会呈现树状结构），如果父类加 载器能够完成，则返回父类加载器加载的Class实例；否则转入步骤3 
 3. 调用本类加载器的findClass（…）方法，试图获取对应的字节码，如果获取的到，则调用defineClass（…）导入类型到方法区；如 果获取不到对应的字节码或者其他原因失败，返回异常给loadClass（…）， loadClass（…）转抛异常，终止加载过程（注意：这里的异常种类不止一种）。 
 - 注意：被两个类加载器加载的同一个类，JVM不认为是相同的类


线程上下文类加载器
双亲委托机制以及默认类加载器的问题 
- 一般情况下, 保证同一个类中所关联的其他类都是由当前类的类加载器所加载的.。 比如，ClassA本身在Ext下找到，那么他里面new出来的一些类也就只能用Ext去查找了（不会低一个级别），所以有 些明明App可以找到的，却找不到了。 
- JDBC API，他有实现的driven部分（mysql/sql server），我们的JDBC API都是由Boot或者Ext来载入的，但是 JDBC driver却是由Ext或者App来载入，那么就有可能找不到driver了。在Java领域中，其实只要分成这种Api+SPI（ Service Provide Interface，特定厂商提供）的，都会遇到此问题。 
- 常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。这些 SPI 的接口由 Java 核心库来提供，如 JAXP 的 SPI 接口定 义包含在 javax.xml.parsers 包中。SPI 的接口是 Java 核心库的一部分，是由引导类加载器来加载的;SPI 实现的  Java 类一般是由系统类加载器来加载的。引导类加载器是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库 。

通常当你需要动态加载资源的时候 , 你至少有三个 ClassLoader 可以选择 : 
- 1.系统类加载器或叫作应用类加载器 (system classloader or application classloader) 
- 2.当前类加载器 
- 3.当前线程类加载器 
当前线程类加载器是为了抛弃双亲委派加载链模式。 
- 每个线程都有一个关联的上下文类加载器。如果你使用new Thread()方式生成新的线程，新线程将继承其父线程的上 下文类加载器。如果程序对线程上下文类加载器没有任何改动的话，程序中所有的线程将都使用系统类加载器作为上下文类加载器。 

Thread.currentThread().getContextClassLoader()

