---
layout: post
title: Java GOF
categories: Java
description: Java 设计模式
keywords: Java
---


创建型模式： 
- 单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。 
结构型模式： 
- 适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。 
行为型模式： 
- 模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模 式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。

# 创建型模式 

单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。 

- 单例模式 保证一个类只有一个实例，并且提供一个访问该实例的全局访问点。 
- 工厂模式
    - 简单工厂模式 用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）
    - 工厂方法模式 用来生产同一等级结构中的固定产品。（支持增加任意产品）
    - 抽象工厂模式 用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）
- 建造者模式 分离了对象子组件的单独构造(由Builder来负责)和装配(由Director负责)。 从而可 以构造出复杂的对象。 
- 原型模式 通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式


## 单例模式
核心作用：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点

常见应用场景
- Windows的Task Manager（任务管理器）就是很典型的单例模式 
- windows的Recycle Bin（回收站）也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。 
- 项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，每次new一个对象去读取。 
- 网站的计数器，一般也是采用单例模式实现，否则难以同步。 
- 应用程序的日志应用，一般都用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作 ，否则内容不好追加。 
- 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。 
- 操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。 
- Application 也是单例的典型应用（Servlet编程中会涉及到） 
- 在Spring中，每个Bean默认就是单例的，这样做的优点是Spring容器可以管理 
- 在servlet编程中，每个Servlet也是单例 
- 在spring MVC框架/struts1框架中，控制器对象也是单例

单例模式优点
- 由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要 比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动 时直接产生一个单例对象，然后永久驻留内存的方式来解决 
- 单例模式可以在系统设置全局的访问点，优化环共享资源访问，例如可以设计 一个单例类，负责所有数据表的映射处理

常见五种单例模式实现方式
- 饿汉式（线程安全，调用效率高。 但是，不能延时加载。） 
- 懒汉式（线程安全，调用效率不高。 但是，可以延时加载。） 
- 双重检测锁式（由于JVM底层内部模型原因(指令重排)，偶尔会出问题。不建议使用） 
- 静态内部类式(线程安全，调用效率高。 但是，可以延时加载) 
- 枚举单例(线程安全，调用效率高，不能延时加载)

### 饿汉式
```java
public class Singleton1 {
    
    //类初始化时，立即加载这个对象（没有延时加载的优势）。加载类时，天然的是线程安全的！
    private static Singleton1 instance = new Singleton1();  
    
    private Singleton1(){
    }
    //方法没有同步，调用效率高！
    public static /*synchronized*/ Singleton1  getInstance(){
        return instance;
    }
    
}
```

- 饿汉式单例模式代码中，static变量会在类装载时初始化，此时也不会涉及多个线程对象访问该对象的问 题。虚拟机保证只会装载一次该类，肯定不会发生并发访问的问题。因此，可以省略synchronized关键字。
- 问题：如果只是加载本类，而不是要调用getInstance()，甚至永远没有调用，则会造成资源浪费！

### 懒汉式
```java
public class Singleton2 {
    
    //类初始化时，不初始化这个对象（延时加载，真正用的时候再创建）。
    private static Singleton2 instance;  
    
    private Singleton2(){ //私有化构造器
    }
    
    //方法同步，调用效率低！
    public static  synchronized Singleton2  getInstance(){
        if(instance==null){
            instance = new Singleton2();
        }
        return instance;
    }
    
}
```
- 问题： 资源利用率高了。但是，每次调用getInstance()方法都要同步，并发效率较低。

### 双重检测锁式
```java
public class Singleton3 {
    //2、提供私有的静态属性
    //没有volatile其他线程可能访问一个没有初始化的对象
    private static volatile Singleton3 instance;  
    //1、构造器私有化 
    private Singleton3() {        
    }
    //3、提供公共的静态方法 --> 获取属性
    public static Singleton3 getInstance() {  
        //再次检测
        if(null!=instance) { //避免不必要的同步 ，已经存在对象
            return instance;
        }
        synchronized(Singleton3.class) {
            if(null == instance) {              
                instance = new Singleton3();
                //1、开辟空间 //2、初始化对象信息 //3、返回对象的地址给引用
            }
        }
        return instance;
    }
}
```

- 这个模式将同步内容下方到if内部，提高了执行的效率不必每次获取对象时都进行同步，只有第一次才同步 创建了以后就没必要了。
- 问题：由于编译器优化原因和JVM底层内部模型原因， 偶尔会出问题。不建议使用。

### 静态内部类式
```java
public class Singleton4 {
    
    private static class SingletonClassInstance {
        private static final Singleton4 instance = new Singleton4();
    }
    
    private Singleton4(){
    }
    //方法没有同步，调用效率高！
    public static Singleton4  getInstance(){
        return SingletonClassInstance.instance;
    }
    
}
```
要点
- 外部类没有static属性，则不会像饿汉式那样立即加载对象。 
- 只有真正调用getInstance(),才会加载静态内部类。加载类时是线程安全的。 instance是static final 类型，保证了内存中只有这样一个实例存在，而且只能被赋值一次，从而保证了线程安全性. 
- 兼备了并发高效调用和延迟加载的优势！

问题
- 反射可以破解上面几种(不包含枚举式)实现方式！（可以在构造方法中手动 抛出异常控制） 
- 反序列化可以破解上面几种((不包含枚举式))实现方式！
    - 可以通过定义readResolve()防止获得不同对象。 
    - 反序列化时，如果对象所在类定义了readResolve()，（实际是一种回调）， 定义返回哪个对象。

### 枚举单例
```java
public enum Singleton5 {
    
    //这个枚举元素，本身就是单例对象！
    INSTANCE;
    
    //添加自己需要的操作！
    public void singletonOperation(){
    }
    
    
}
```
优点： 
- 实现简单 
- 枚举本身就是单例模式。由JVM从根本上提供保障！避免通过反射和反序列化的漏洞！ 
缺点： 
- 无延迟加载

 如何选用? 
 - 单例对象  占用资源少，不需要延时加载： 
    - 枚举式   好于   饿汉式 
 - 单例对象  占用资源大，需要延时加载： 
    - 静态内部类式   好于  懒汉式

## 工厂模式

核心本质： 
- 实例化对象，用工厂方法代替new操作。 
- 将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。


- 简单工厂模式 • 用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码） 
- 工厂方法模式 • 用来生产同一等级结构中的固定产品。（支持增加任意产品）   
- 抽象工厂模式 • 用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族） 

应用场景 
- JDK中Calendar的getInstance方法 
- JDBC中Connection对象的获取 
- Hibernate中SessionFactory创建Session 
- spring中IOC容器创建管理bean对象 
- XML解析时的DocumentBuilderFactory创建解析器对象 
- 反射中Class对象的newInstance()

### 简单工厂模式

要点
- 简单工厂模式也叫静态工厂模式，就是工厂类一般是使用静态方法， 通过接收的参数的不同来返回不同的对象实例。 
- 对于增加新产品无能为力！不修改代码的话，是无法扩展的。

### 工厂方法模式
要点
- 为了避免简单工厂模式的缺点，不完全满足OCP。 
- 工厂方法模式和简单工厂模式最大的不同在于，简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。

简单工厂模式 VS 工厂方法模式
- 结构复杂度 从这个角度比较，显然简单工厂模式要占优。简单工厂模式只需一个工厂类，而工厂方法模式的工厂类随着产品类个 数增加而增加，这无疑会使类的个数越来越多，从而增加了结构的复杂程度。 
- 代码复杂度 代码复杂度和结构复杂度是一对矛盾，既然简单工厂模式在结构方面相对简洁，那么它在代码方面肯定是比工厂方法 模式复杂的了。简单工厂模式的工厂类随着产品类的增加需要增加很多方法（或代码），而工厂方法模式每个具体工 厂类只完成单一任务，代码简洁。 
- 客户端编程难度 工厂方法模式虽然在工厂类结构中引入了接口从而满足了OCP，但是在客户端编码中需要对工厂类进行实例化。而简 单工厂模式的工厂类是个静态类，在客户端无需实例化，这无疑是个吸引人的优点。 
- 管理上的难度 这是个关键的问题。 我们先谈扩展。众所周知，工厂方法模式完全满足OCP，即它有非常良好的扩展性。那是否就说明了简单工厂模式就 没有扩展性呢？答案是否定的。简单工厂模式同样具备良好的扩展性——扩展的时候仅需要修改少量的代码（修改工 厂类的代码）就可以满足扩展性的要求了。尽管这没有完全满足OCP，但我们不需要太拘泥于设计理论，要知道， sun提供的java官方工具包中也有想到多没有满足OCP的例子啊。 然后我们从维护性的角度分析下。假如某个具体产品类需要进行一定的修改，很可能需要修改对应的工厂类。当同时 需要修改多个产品类的时候，对工厂类的修改会变得相当麻烦（对号入座已经是个问题了）。反而简单工厂没有这些 麻烦，当多个产品类需要修改是，简单工厂模式仍然仅仅需要修改唯一的工厂类（无论怎样都能改到满足要求吧？大 不了把这个类重写）。 

### 抽象工厂模式
要点
- 用来生产不同产品族的全部产品。（对于增加新的产品，无能为力； 支持增加产品族） 
- 抽象工厂模式是工厂方法模式的升级版本，在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。


## 建造者模式

建造者模式本质
- 分离了对象子组件的单独构造(由Builder来负责)和装配(由Director负责)。从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况下使用。 
- 由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配 算法的解耦，实现了更好的复用。

开发中应用场景： 
- StringBuilder类的append方法 
- SQL中的PreparedStatement 
- JDOM中，DomBuilder、SAXBuilder


## 原型模式prototype

原型模式： 
- 通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。
- 就是java中的克隆技术，以某个对象为原型，复制出新的对象。显然，新的对象具备原型对象的特点
- 优势有：效率高(直接克隆，避免了重新执行构造过程步骤) 。 
- 克隆类似于new，但是不同于new。new创建新的对象属性采用的是默认值。克隆出的对象的属性值完全和原型对象相同。并且克隆出的新对象改变不会影响原型对象。然后， 再修改克隆对象的值。 

原型模式实现： 
- Cloneable接口和clone方法 
- Prototype模式中实现起来最困难的地方就是内存复制操作，所幸在Java中提供了clone()方法替我们做了绝大部分事情。 

浅克隆存在的问题 
- 被复制的对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都 仍然指向原来的对象。 深克隆如何实现? 
- 深克隆把引用的变量指向复制过的新对象，而不是原有的被引用的对象。 
- 深克隆：让已实现Clonable接口的类中的属性也实现Clonable接口 
- 基本数据类型和String能够自动实现深度克隆（值的复制）
- 利用序列化和反序列化技术实现深克隆！ 

开发中的应用场景 
- 原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者。 
    -pring中bean的创建实际就是两种：单例模式和原型模式。（当然，原型模式需要和工厂模式搭配起来）




# 结构型模式
核心作用：是从程序的结构上实现松耦合，从而可以扩大整体的类结 构，用来解决更大的问题。 
分类： 适配器模式、代理模式、桥接模式、 装饰模式、组合模式、外观模式、享元模式

汇总  
| ----- | :-----------------------------------------  |
|代理模式|为真实对象提供一个代理，从而控制对真实对象的访问|
|适配模式|使原本由于接口不兼容不能一起工作的类可以一起工作|
|桥接模式|处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联。|
|组合模式|将对象组合成树状结构以表示”部分和整体”层次结构，使得客户可以统一的调用叶子对象和容器对象|
|装饰模式|动态地给一个对象添加额外的功能，比继承灵活|
|外观模式|为子系统提供统一的调用接口，使得子系统更加容易使用|
|享元模式|运用共享技术有效的实现管理大量细粒度对象，节省内存，提高效率|

## 适配器adapter模式

工作场景
- 经常用来做旧系统改造和升级 
- 如果我们的系统开发之后再也不需要维护，那么很多模式都是没必要的，但是不幸的是，事实却是维护一个系统的代价往往是开发一个系 统的数倍。 

其他场景
- java.io.InputStreamReader(InputStream) 
- java.io.OutputStreamWriter(OutputStream)

## 代理模式proxy

核心作用： 
- 通过代理，控制对对象的访问！可以详细控制访问某个（某类）对象的方法，在调用这个方法前做前置处理，调用这个方法后 做后置处理。（即：AOP的微观实现！） 
- AOP(Aspect  Oriented  Programming面向切面编程)的核心实现机制！

核心角色： 
- 抽象角色  定义代理角色和真实角色的公共对外方法 
- 真实角色  
    - 实现抽象角色，定义真实角色所要实现的业务逻辑， 供代理角色调用。 
    - 关注真正的业务逻辑！ 
- 代理角色  实现抽象角色，是真实角色的代理，通过真实角色 的业务逻辑方法来实现抽象方法，并可以附加自己的操作。

应用场景： 
- 安全代理：屏蔽对真实角色的直接访问。 
- 远程代理：通过代理类处理远程方法调用(RMI) 
- 延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象。 

分类： 
- 静态代理(静态定义代理类) 
- 动态代理(动态生成代理类) ：抽象角色中(接口)声明的所以方法都被转移到调用处理器一个集中的方 法中处理，这样，我们可以更加灵活和统一的处理众多的方法。
    - JDK自带的动态代理
        - java.lang.reflect.Proxy • 作用：动态生成代理类和对象 
        - java.lang.reflect.InvocationHandler(处理器接口) 
            - 可以通过invoke方法实现对真实角色的代理访问。 
            - 每次通过Proxy生成代理类对象对象时都要指定对应的处理器对象

    - javaassist字节码操作库实现 
    - CGLIB 
    - ASM(底层使用指令，可维护性较差)

开发框架中应用场景： 
- struts2中拦截器的实现 
- 数据库连接池关闭处理 
- Hibernate中延时加载的实现 
- mybatis中实现拦截器插件 
- AspectJ的实现 
- spring中AOP的实现 
    - 日志拦截 
    - 声明式事务处理 
- web service 
- RMI远程方法调用 
- ...


## 桥接模式bridge

桥接模式核心要点： 
- 处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联。

桥接模式总结： 
- 桥接模式可以取代多层继承的方案。多层继承违背了单一职责原则，复用性较差，类的个数也非常多。桥接模式可以极大的减少子类的个数，从而降低管理和维护的成本。 
- 桥接模式极大的提高了系统可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有的系统，符合开闭原则。


 桥接模式实际开发中应用场景 
 - JDBC驱动程序 
 - AWT中的Peer架构 
 - 银行日志管理： 
     - 格式分类：操作日志、交易日志、异常日志 
     - 距离分类：本地记录日志、异地记录日志 
 - 人力资源系统中的奖金计算模块： 
     - 奖金分类：个人奖金、团体奖金、激励奖金。 
     - 部门分类：人事部门、销售部门、研发部门。 
 - OA系统中的消息处理： 
     - 业务类型：普通消息、加急消息、特急消息 
     - 发送消息方式：系统内消息、手机短信、邮件

## 组合模式composite

组合模式核心： 
- 抽象构件(Component)角色: 定义了叶子和容器构件的共同点 
- 叶子(Leaf)构件角色：无子节点 
- 容器(Composite)构件角色： 有容器特征，可以包含子节点

 组合模式工作流程分析： 
 - 组合模式为处理树形结构提供了完美的解决方案，描述了如何将容器和叶子进行递归组合，使得用户在使用时可以一致性的对待容器和叶子。 
 - 当容器对象的指定方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员，并调用执行。其中，使用了递归调用的机制对整个结构进行处理。

 开发中的应用场景： 
 - 操作系统的资源管理器 
 - GUI中的容器层次图 
 - XML文件解析 - OA系统中，组织结构的处理 
 - Junit单元测试框架 
    - 底层设计就是典型的组合模式，TestCase(叶子)、TestUnite(容器) 、Test接口(抽象)

## 装饰模式decorator

装饰模式职责
- 动态的为一个对象增加新的功能
- 用于代替继承，无需通过继承增加子类就能扩展对象新功能，使用对象关联关系代替继承关系，更加灵活，同事避免体系的快速膨胀

实现细节
- Component抽象构件角色： 真实对象和装饰对象有相同的接口。客户端对象就能够以与真实对象相同的方式同装饰 对象交互。 
- ConcreteComponent 具体构件角色(真实对象)： io流中的FileInputStream、FileOutputStream 
- Decorator装饰角色：持有一个抽象构件的引用。装饰对象接受所有客户端的请求，并把这些请求转发给真实的对象 。这样，就能在真实对象调用前后增加新的功能。 
- ConcreteDecorator具体装饰角色： 负责给构件对象增加新的责任。

开发中使用的场景： 
- IO中输入流和输出流的设计 
- Swing包中图形界面构件功能 
- Servlet API 中提供了一个request对象的Decorator设计模式的默认实现类HttpServletRequestWrapper，HttpServletRequestWrapper 类，增强了request对象的功能。 
- Struts2中，request，response,session对象的处理

总结： 
- 装饰模式（Decorator）也叫包装器模式（Wrapper） 
- 装饰模式降低系统的耦合度，可以动态的增加或删除对象的职责，并使得需要装饰的具体构建类和具体装饰类可以独立变化，以便增加新 的具体构建类和具体装饰类。 

优点 
- 扩展对象功能，比继承灵活，不会导致类个数急剧增加 
- 可以对一个对象进行多次装饰，创造出不同行为的组合，得到功能更 加强大的对象 
- 具体构建类和具体装饰类可以独立变化，用户可以根据需要自己增加 新的具体构件子类和具体装饰子类。 
缺点 
- 产生很多小对象。大量小对象占据内存，一定程度上影响性能。 
- 装饰模式易于出错，调试排查比较麻烦。

装饰模式和桥接模式的区别： 
- 两个模式都是为了解决过多子类对象问题。但他们の诱因不一样。桥模式是对象自身现有机制沿着多个维度变化，是既有部分不稳定。装饰模式是为了增加新的功能。

## 外观模式facade

外观模式核心： 为子系统提供统一的入口。封装子系统的复杂性，便于客户端调用。
开发中常见的场景 
- 频率很高。哪里都会遇到。各种技术和框架中，都有外观模式的使用。如： 
    - JDBC封装后的，commons提供的DBUtils类， Hibernate提供的工具类、Spring JDBC工具类等

## 享元模式flyweight


核心： 
- 享元模式以共享的方式高效地支持大量细粒度对象的重用。
- 享元对象能做到共享的关键是区分了内部状态和外部状态。 
    - 内部状态：可以共享，不会随环境变化而改变 
    - 外部状态：不可以共享，会随环境变化而改变

享元模式实现： 
- FlyweightFactory享元工厂类 
    - 创建并管理享元对象，享元池一般设计成键值对 
- FlyWeight抽象享元类 
    - 通常是一个接口或抽象类，声明公共方法，这些方法可以向外界提供对象 的内部状态，设置外部状态。 
- ConcreteFlyWeight具体享元类 
    - 为内部状态提供成员变量进行存储 
- UnsharedConcreteFlyWeight非共享享元类 
    - 不能被共享的子类可以设计为非共享享元类

享元模式开发中应用的场景： 
- 享元模式由于其共享的特性，可以在任何“池”中操作， 比如：线程池、数据库连接池。 
- String类的设计也是享元模式


优点 
- 极大减少内存中对象的数量 
- 相同或相似对象内存中只存一份，极大的节约资源，提高系统性能 
- 外部状态相对独立，不影响内部状态 
缺点 
- 模式较复杂，使程序逻辑复杂化 
- 为了节省内存，共享了内部状态，分离出外部状态，而读取外部状态使运行时间变长。用时间换取了空间。

# 行为型模式

汇总
1. 责任链模式       chain of responsibility
2. 命令模式         command 
3. 迭代器模式       iterator
4. 终结者模式       mediator
5. 备忘录模式       memento
6. 观察者模式       observer
7. 状态模式         state
8. 策略模式         strategy
9. 模板方法模式    template method
10. 解释器模式       interpretor
11. 访问者模式      visitor

| ----- | :---------------------------------------------------  |
|职责链模式|避免请求发送者和接收者耦合，让多个对象都有可能接收请求，将这些对象连成一条链，并且沿 着这条链传递请求，直到有对象处理为止|
|命令模式|将一个请求封装为一个对象，从而使得请求调用者和请求接收者解耦|
|解释器模式|描述如何为语言定义一个文法，如何解析|
|迭代器模式|提供了一种方法来访问聚合对象|
|中介者模式|通过一个中介对象来封装一系列的对象交互，使得各对象不需要相互引用|
|备忘录模式|捕获一个对象的内部状态，并保存之；需要时，可以恢复到保存的状态|
|观察者模式|当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新|
|状态模式|允许一个对象在其内部状态改变时改变它的行为|
|策略模式|定义一系列算法，并将每个算法封装在一个类中|
|模板方法|定义一个操作的算法骨架，将某些易变的步骤延迟到子类中实现|
|访问者模式|表示一个作用于某对象结构中的各元素的操作，它使得用户可以在不改变各元素的类的前提下定 义作用于这些元素的新操作|

## 责任链模式chain of responsibility

定义
- 将能够处理同一类请求的对象连成一条链，所提交的请求沿着链传递，链上的对象诸葛判断是否有能力处理该请求，如果能则处理，如果不能则传递给链上下一个对象
-  添加新的处理对象
    - 由于责任链的创建完全在客户端，因此新增新的具体处理者对原有类 库没有任何影响，只需添加新的类，然后在客户端调用时添加即可。 符合开闭原则

- 链表方式定义职责链(上一个案例) 
- 非链表方式实现职责链 
    - 通过集合、数组生成职责链更加实用！实际上，很多项目中，每个具体的Handler并不是由开发团队定义的，而是项目上线后由外部单位追加的，所以使用链表方式定义COR链就很困难。

开发中常见的场景： 
- Java中，异常机制就是一种责任链模式。一个try可以对应多个catch，当第一个catch不匹配类型，则自动跳到第二个catch. 
- Javascript语言中，事件的冒泡和捕获机制。Java语言中，事件的处理采用责任链模式。 
- Servlet开发中，过滤器的链式处理 - Struts2中，拦截器的调用也是典型的责任链模式

## 迭代器模式iterator

场景： 
- 提供一种可以遍历聚合对象的方式。又称为：游标cursor模式 
- 聚合对象：存储数据 
- 迭代器：遍历数据

结构： 
- 聚合对象：存储数据 
- 迭代器：遍历数据

基本案例： 
- 实现正向遍历的迭代器 
- 实现逆向遍历的迭代器
开发中常见的场景： - JDK内置的迭代器(List/Set)

## 中介者模式

核心
- 如果一个系统中都乡之间的联系呈现网状结构，独享之间存在大量多对多关系，将导致关系极其复杂，这些对象成为“同事对象”
- 我们可以引入一个中介者对象，使各个同事对象只跟中介者打交道

实现
- 抽象中介者：定义同事对象到中介者对象
- 具体中介者：实现抽象类方法，需要知道所有具体同事类，并从具体同时接收消息，向具体同事对象发出消息
- 抽象同事类
- 具体同事类：每个具体同事只知道自己的行为，而不了解其他同事类情况，但都认识中介者对象

中介者模式的本质： 
- 解耦多个同事对象之间的交互关系。每个对象都持有中介者对象的引用，只跟中介者对象打交道。我们通过中介者对象统一管理这些交互 关系
开发中常见的场景： 
- MVC模式(其中的C，控制器就是一个中介者对象。M和V都和他打交道) 
- 窗口游戏程序，窗口软件开发中窗口对象也是一个中介者对象 
- 图形界面开发GUI中，多个组件之间的交互，可以通过引入一个中介者对象来解决，可以是整体的窗口对象或者DOM对象 
- Java.lang.reflect.Method#invoke()


## 命令模式command

介绍
- 将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。也称为动作Action模式，事物transaction模式

结构
- Command抽象命令类
- ConcreteCommand具体命令类
- Invoker调用者/请求者
    - 请求的发送者，通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此他之余抽象命令类之间存在关联。在程序运行时，将调用命令对象的execute()，间接调用接收者的相关操作。
- Receiver接收者
    - 接收者执行与请求相关的操作，具体实现对请求的业务处理
    - 未抽象前，实际执行操作内容的对象





开发中常见的场景： 
- Struts2中，action的整个调用过程中就有命令模式。 
- 数据库事务机制的底层实现 
- 命令的撤销和恢复


## 解释器模式interpretor

介绍
- 是一种不常用的设计模式 
- 用于描述如何构成一个简单的语言解释器，主要用于使用面向对象语言开发的 编译器和解释器设计。 - 当我们需要开发一种新的语言时，可以考虑使用解释器模式。 
- 尽量不要使用解释器模式，后期维护会有很大麻烦。在项目中，可以使用Jruby，Groovy、java的js引擎来替代解释器的作用，弥补java语言的不足。


开发中常见的场景
- EL表达式式的处理 
- 正则表达式解释器 
- SQL语法的解释器 
- 数学表达式解析器 
    - 如现成的工具包:Math Expression String Parser、Expression4J等。

## 访问者模式

模式动机： 
- 对于存储在一个集合中的对象，他们可能具有不同的类型(即使有一个公共的接口)，对于该集合中的对象，可以接受一类称为访问者的对象来访问，不同的访问者其访问方式也有所不同。 

定义： 
- 表示一个作用于某对象结构中的各元素的操作，它使我们可以在不改变个元素的类的前提下定义作用于这些元素的新操作。

开发中的场景(应用范围非常窄，了解即可)： 
- XML文档解析器设计 
- 编译器的设计 
- 复杂集合对象的处理


## 策略模式strategy

策略模式 
- 策略模式对应于解决某一个问题的一个算法族，允许用户从该算法族中任选一个算法解决某一问题，同时可以方便的更换算法或者增加新的算法。并且由客户端决定调用哪个算法。 

本质： 
- 分离算法，选择实现。

开发中常见的场景： 
- JAVASE中GUI编程中，布局管理 - Spring框架中，Resource接口，资源访问策略 - javax.servlet.http.HttpServlet#service()


## 模板方法模式template method

介绍
- 模板方法模式是编程中经常用到的模式。定义了一个操作中的算法骨架，将某些步骤延迟到子类中实现。这样，新的子类可以在不改变一个算法结构的前提下重新定义该算法的某些特定步骤。

核心
- 处理步骤父类中定义好，具体实现延迟到子类中定义
- 方法回调(钩子方法)
    -子类不能调用父类，而通过父类调用子类，调用步骤已在父类中写好，完全由父类控制过程

什么时候用到模板方法
- 实现一个算法，整体步骤很固定，但是某些部分易变，易变部分抽象出来供子类实现

开发中常见场景
- 数据库访问的封装
- Junit单元测试
- servlet中关于doGet/doPost方法调用
- Hibernate中模板程序
- Spring中JDBCTemplate、HibernateTemplate等


## 状态模式state

核心
- 用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题 

结构 
- Context环境类 ：环境类中维护一个State对象，他是定义了当前的状态。 
- State抽象状态类 
- ConcreteState具体状态类 ：每一个类封装了一个状态对应的行为

开发中常见的场景： 
- 银行系统中账号状态的管理 
- OA系统中公文状态的管理 
- 酒店系统中，房间状态的管理 
- 线程对象各状态之间的切换



## 观察者模式observer

核心
- 观察者模式主要用于1：N的通知。当一个对象(目标对象subject/obversable)的状态改变时，需要及时告知一系列对象(观察者对象/obverser)，令他们作出响应

通知观察者方式
- 推：通知以广播方式发送给所有观察者，所有观察者被动接收
- 拉：观察者只需知道有情况即可，至于什么时候获取，获取什么内容自主决定

开发中常见的场景： 
- 聊天室程序的，服务器转发给所有客户端 
- 网络游戏(多人联机对战)场景中，服务器将客户端的状态进行分发 
- 邮件订阅 
- Servlet中，监听器的实现 
- Android中，广播机制 
- JDK的AWT中事件处理模型,基于观察者模式的委派事件模型(Delegation  Event  Model) 
    - 事件源----------------目标对象 
    - 事件监听器------------观察者 
- 京东商城中，群发某商品打折信息

## 备忘录模式memento

核心 
– 就是保存某个对象内部状态的拷贝，这样以后就可以将该对象恢复到 原先的状态。 
结构： 
– 源发器类Originator(createMemento,setMemento) 
– 备忘录类Memento
– 负责人类CareTaker
    - 负责保存好的备忘录对象
    - 可以通过增加容器，设置多个“备忘点”

开发中常见的应用场景： 
– 棋类游戏中的，悔棋 
– 普通软件中的，撤销操作 
– 数据库软件中的，事务管理中的，回滚操作 
– Photoshop软件中的，历史记录




























